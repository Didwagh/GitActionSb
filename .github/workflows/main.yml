name: Deploy Spring Boot Gradle to Pinggy
on: 
  push:
    branches: [ main, master ]
  workflow_dispatch: # Allow manual trigger

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'
      
      - name: Cache Gradle dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-
      
      - name: Verify project structure
        run: |
          echo "üîç Checking project structure..."
          ls -la
          echo "üìÅ Looking for build.gradle files:"
          find . -name "build.gradle" -type f
          
          if [ ! -f "build.gradle" ]; then
            echo "‚ùå No build.gradle found in root directory"
            echo "Please ensure your Spring Boot project is in the repository root"
            exit 1
          fi
          
          echo "‚úÖ build.gradle found, checking if it's a Spring Boot project..."
          if grep -q "spring-boot" build.gradle; then
            echo "‚úÖ Spring Boot dependencies found"
          else
            echo "‚ö†Ô∏è  Warning: No Spring Boot dependencies detected in build.gradle"
          fi
          
          echo "üìÅ Source structure:"
          find src -type f -name "*.java" | head -10
      
      - name: Make gradlew executable
        run: chmod +x ./gradlew
      
      - name: Build with Gradle
        run: |
          echo "üèóÔ∏è Building Spring Boot application..."
          ./gradlew clean build -x test --no-daemon
          
          echo "üì¶ Checking build output..."
          ls -la build/libs/
          
          if ls build/libs/*.jar 1> /dev/null 2>&1; then
            echo "‚úÖ JAR file built successfully:"
            ls -la build/libs/*.jar
          else
            echo "‚ùå No JAR file found in build/libs directory"
            exit 1
          fi
      
      - name: Start Spring Boot application
        run: |
          echo "üöÄ Starting Spring Boot application..."
          
          # Find the JAR file (exclude plain JARs)
          JAR_FILE=$(find build/libs -name "*.jar" -not -name "*-plain.jar" | head -1)
          
          if [ -z "$JAR_FILE" ]; then
            echo "‚ùå No executable JAR found"
            echo "Available files in build/libs:"
            ls -la build/libs/
            exit 1
          fi
          
          echo "üì¶ Starting JAR: $JAR_FILE"
          
          # Start the application in background
          nohup java -jar "$JAR_FILE" > app.log 2>&1 &
          APP_PID=$!
          echo "üÜî Application PID: $APP_PID"
          echo $APP_PID > app.pid
          
          # Wait for application to start
          echo "‚è≥ Waiting for application to start..."
          for i in {1..60}; do
            if curl -s http://localhost:8080/actuator/health > /dev/null 2>&1; then
              echo "‚úÖ Application health check passed"
              break
            elif curl -s http://localhost:8080 > /dev/null 2>&1; then
              echo "‚úÖ Application is responding"
              break
            else
              if [ $i -eq 60 ]; then
                echo "‚ùå Application failed to start within 60 seconds"
                echo "üìã Application logs:"
                cat app.log
                exit 1
              fi
              echo "‚è≥ Waiting... ($i/60)"
              sleep 1
            fi
          done
      
      - name: Test local endpoints
        run: |
          echo "üß™ Testing local endpoints..."
          
          # Test root endpoint
          echo "Testing http://localhost:8080/"
          curl -v http://localhost:8080/ || echo "Root endpoint not available"
          
          # Test health endpoint
          echo "Testing http://localhost:8080/actuator/health"
          curl -v http://localhost:8080/actuator/health || echo "Health endpoint not available"
          
          # Test any custom /api endpoint
          echo "Testing http://localhost:8080/api"
          curl -v http://localhost:8080/api || echo "API endpoint not available"
          
          echo "üìã Application logs so far:"
          cat app.log
      
      - name: Create Pinggy tunnel
        run: |
          echo "üåê Creating Pinggy tunnel..."
          ssh -p 443 \
              -o StrictHostKeyChecking=no \
              -o UserKnownHostsFile=/dev/null \
              -o ServerAliveInterval=30 \
              -R0:localhost:8080 a.pinggy.io &
          
          TUNNEL_PID=$!
          echo "üÜî Tunnel PID: $TUNNEL_PID"
          echo $TUNNEL_PID > tunnel.pid
          
          sleep 10
          echo "‚úÖ Tunnel created! Check logs above for public URL"
      
      - name: Keep workflow alive and monitor
        run: |
          echo "üïê Keeping workflow alive for 10 minutes..."
          echo "üîó Your Spring Boot app should be accessible via the Pinggy URL above"
          
          for i in {1..20}; do
            echo "‚è≥ $((i*30)) seconds elapsed..."
            
            # Show recent app logs
            if [ -f app.log ]; then
              echo "üìã Recent application logs:"
              tail -5 app.log
            fi
            
            # Check if app is still running
            if [ -f app.pid ]; then
              APP_PID=$(cat app.pid)
              if ps -p $APP_PID > /dev/null 2>&1; then
                echo "‚úÖ App process still running (PID: $APP_PID)"
              else
                echo "‚ö†Ô∏è App process not found"
              fi
            fi
            
            # Test local connectivity
            if curl -s http://localhost:8080 > /dev/null 2>&1; then
              echo "‚úÖ App still responding locally"
            else
              echo "‚ö†Ô∏è App not responding locally"
            fi
            
            sleep 30
          done
          
          echo "‚úÖ Workflow completed"